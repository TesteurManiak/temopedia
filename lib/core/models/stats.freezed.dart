// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'stats.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Stats _$StatsFromJson(Map<String, dynamic> json) {
  return _Stats.fromJson(json);
}

/// @nodoc
mixin _$Stats {
  int get hp => throw _privateConstructorUsedError;
  int get st => throw _privateConstructorUsedError;
  int get dx => throw _privateConstructorUsedError;
  int get iq => throw _privateConstructorUsedError;
  int get sp => throw _privateConstructorUsedError;
  int get at => throw _privateConstructorUsedError;
  int get df => throw _privateConstructorUsedError;
  int get sa => throw _privateConstructorUsedError;
  int get sd => throw _privateConstructorUsedError;
  int get ev => throw _privateConstructorUsedError;
  int get ac => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StatsCopyWith<Stats> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StatsCopyWith<$Res> {
  factory $StatsCopyWith(Stats value, $Res Function(Stats) then) =
      _$StatsCopyWithImpl<$Res, Stats>;
  @useResult
  $Res call(
      {int hp,
      int st,
      int dx,
      int iq,
      int sp,
      int at,
      int df,
      int sa,
      int sd,
      int ev,
      int ac});
}

/// @nodoc
class _$StatsCopyWithImpl<$Res, $Val extends Stats>
    implements $StatsCopyWith<$Res> {
  _$StatsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hp = null,
    Object? st = null,
    Object? dx = null,
    Object? iq = null,
    Object? sp = null,
    Object? at = null,
    Object? df = null,
    Object? sa = null,
    Object? sd = null,
    Object? ev = null,
    Object? ac = null,
  }) {
    return _then(_value.copyWith(
      hp: null == hp
          ? _value.hp
          : hp // ignore: cast_nullable_to_non_nullable
              as int,
      st: null == st
          ? _value.st
          : st // ignore: cast_nullable_to_non_nullable
              as int,
      dx: null == dx
          ? _value.dx
          : dx // ignore: cast_nullable_to_non_nullable
              as int,
      iq: null == iq
          ? _value.iq
          : iq // ignore: cast_nullable_to_non_nullable
              as int,
      sp: null == sp
          ? _value.sp
          : sp // ignore: cast_nullable_to_non_nullable
              as int,
      at: null == at
          ? _value.at
          : at // ignore: cast_nullable_to_non_nullable
              as int,
      df: null == df
          ? _value.df
          : df // ignore: cast_nullable_to_non_nullable
              as int,
      sa: null == sa
          ? _value.sa
          : sa // ignore: cast_nullable_to_non_nullable
              as int,
      sd: null == sd
          ? _value.sd
          : sd // ignore: cast_nullable_to_non_nullable
              as int,
      ev: null == ev
          ? _value.ev
          : ev // ignore: cast_nullable_to_non_nullable
              as int,
      ac: null == ac
          ? _value.ac
          : ac // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_StatsCopyWith<$Res> implements $StatsCopyWith<$Res> {
  factory _$$_StatsCopyWith(_$_Stats value, $Res Function(_$_Stats) then) =
      __$$_StatsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int hp,
      int st,
      int dx,
      int iq,
      int sp,
      int at,
      int df,
      int sa,
      int sd,
      int ev,
      int ac});
}

/// @nodoc
class __$$_StatsCopyWithImpl<$Res> extends _$StatsCopyWithImpl<$Res, _$_Stats>
    implements _$$_StatsCopyWith<$Res> {
  __$$_StatsCopyWithImpl(_$_Stats _value, $Res Function(_$_Stats) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hp = null,
    Object? st = null,
    Object? dx = null,
    Object? iq = null,
    Object? sp = null,
    Object? at = null,
    Object? df = null,
    Object? sa = null,
    Object? sd = null,
    Object? ev = null,
    Object? ac = null,
  }) {
    return _then(_$_Stats(
      hp: null == hp
          ? _value.hp
          : hp // ignore: cast_nullable_to_non_nullable
              as int,
      st: null == st
          ? _value.st
          : st // ignore: cast_nullable_to_non_nullable
              as int,
      dx: null == dx
          ? _value.dx
          : dx // ignore: cast_nullable_to_non_nullable
              as int,
      iq: null == iq
          ? _value.iq
          : iq // ignore: cast_nullable_to_non_nullable
              as int,
      sp: null == sp
          ? _value.sp
          : sp // ignore: cast_nullable_to_non_nullable
              as int,
      at: null == at
          ? _value.at
          : at // ignore: cast_nullable_to_non_nullable
              as int,
      df: null == df
          ? _value.df
          : df // ignore: cast_nullable_to_non_nullable
              as int,
      sa: null == sa
          ? _value.sa
          : sa // ignore: cast_nullable_to_non_nullable
              as int,
      sd: null == sd
          ? _value.sd
          : sd // ignore: cast_nullable_to_non_nullable
              as int,
      ev: null == ev
          ? _value.ev
          : ev // ignore: cast_nullable_to_non_nullable
              as int,
      ac: null == ac
          ? _value.ac
          : ac // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Stats extends _Stats {
  const _$_Stats(
      {this.hp = 0,
      this.st = 0,
      this.dx = 0,
      this.iq = 0,
      this.sp = 0,
      this.at = 0,
      this.df = 0,
      this.sa = 0,
      this.sd = 0,
      this.ev = 0,
      this.ac = 0})
      : super._();

  factory _$_Stats.fromJson(Map<String, dynamic> json) =>
      _$$_StatsFromJson(json);

  @override
  @JsonKey()
  final int hp;
  @override
  @JsonKey()
  final int st;
  @override
  @JsonKey()
  final int dx;
  @override
  @JsonKey()
  final int iq;
  @override
  @JsonKey()
  final int sp;
  @override
  @JsonKey()
  final int at;
  @override
  @JsonKey()
  final int df;
  @override
  @JsonKey()
  final int sa;
  @override
  @JsonKey()
  final int sd;
  @override
  @JsonKey()
  final int ev;
  @override
  @JsonKey()
  final int ac;

  @override
  String toString() {
    return 'Stats(hp: $hp, st: $st, dx: $dx, iq: $iq, sp: $sp, at: $at, df: $df, sa: $sa, sd: $sd, ev: $ev, ac: $ac)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Stats &&
            (identical(other.hp, hp) || other.hp == hp) &&
            (identical(other.st, st) || other.st == st) &&
            (identical(other.dx, dx) || other.dx == dx) &&
            (identical(other.iq, iq) || other.iq == iq) &&
            (identical(other.sp, sp) || other.sp == sp) &&
            (identical(other.at, at) || other.at == at) &&
            (identical(other.df, df) || other.df == df) &&
            (identical(other.sa, sa) || other.sa == sa) &&
            (identical(other.sd, sd) || other.sd == sd) &&
            (identical(other.ev, ev) || other.ev == ev) &&
            (identical(other.ac, ac) || other.ac == ac));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, hp, st, dx, iq, sp, at, df, sa, sd, ev, ac);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StatsCopyWith<_$_Stats> get copyWith =>
      __$$_StatsCopyWithImpl<_$_Stats>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_StatsToJson(
      this,
    );
  }
}

abstract class _Stats extends Stats {
  const factory _Stats(
      {final int hp,
      final int st,
      final int dx,
      final int iq,
      final int sp,
      final int at,
      final int df,
      final int sa,
      final int sd,
      final int ev,
      final int ac}) = _$_Stats;
  const _Stats._() : super._();

  factory _Stats.fromJson(Map<String, dynamic> json) = _$_Stats.fromJson;

  @override
  int get hp;
  @override
  int get st;
  @override
  int get dx;
  @override
  int get iq;
  @override
  int get sp;
  @override
  int get at;
  @override
  int get df;
  @override
  int get sa;
  @override
  int get sd;
  @override
  int get ev;
  @override
  int get ac;
  @override
  @JsonKey(ignore: true)
  _$$_StatsCopyWith<_$_Stats> get copyWith =>
      throw _privateConstructorUsedError;
}
